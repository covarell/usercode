process Alignment = {
    
    # initialize  MessageLogger
    service = MessageLogger { 
        untracked vstring destinations = { "cout", "alignment" } # .log automatically
		untracked vstring statistics = { "cout", "alignment"}
        
		untracked vstring categories = { "Alignment" }
		
		untracked PSet cout= { 
			untracked string threshold = "DEBUG" 
			untracked bool noLineBreaks = true 
		}
		untracked PSet alignment  = { 
			untracked string threshold = "INFO" 
			untracked PSet INFO = { untracked int32 limit = 0 }
			untracked PSet WARNING = { untracked int32 limit = 0 }
			untracked PSet ERROR = { untracked int32 limit = 0 }
			untracked PSet DEBUG = { untracked int32 limit = 0 }
			untracked PSet Alignment = { untracked int32 limit = -1}
			untracked bool noLineBreaks = true 
		}
        #   vstring debugModules = { "*" }
	}
	
	# initialize magnetic field
	include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"
	include "MagneticField/Engine/data/uniformMagneticField.cfi"
        es_prefer = UniformMagneticFieldESProducer{}
        replace UniformMagneticFieldESProducer.ZFieldInTesla = 0.0

	# ideal geometry and interface
	include "Geometry/CMSCommonData/data/cmsIdealGeometryXML.cfi"
	include "Geometry/TrackerNumberingBuilder/data/trackerNumberingGeometry.cfi"
	
	# track selection for alignment
        # include "Alignment/CommonAlignmentProducer/data/AlignmentTrackSelector.cfi" 
	
	# Alignment producer
	include "Alignment/CommonAlignmentProducer/data/AlignmentProducer.cff"
        # replace AlignmentProducer.ParameterBuilder.Selector.alignParams = { "TIBSSLayers,100010" }

        replace AlignmentProducer.ParameterBuilder.Selector.alignParams = { "TIBRods,100001,TIBSelOnly" }
        replace AlignmentProducer.ParameterBuilder.Selector.TIBSelOnly.phiRanges = {1.0, 2.355}
        replace AlignmentProducer.ParameterBuilder.Selector.TIBSelOnly.etaRanges = {0., 3.0} 
       
        replace AlignmentProducer.isData = true
        replace AlignmentProducer.tkTag = TrackRefitter
        replace AlignmentProducer.tjTag = TrackRefitter

        # replace AlignmentProducer.doMisalignmentScenario = true
        replace AlignmentProducer.randomShift = 0.00
        replace AlignmentProducer.randomRotation = 0.00	
        replace HIPAlignmentAlgorithm.eventPrescale = 1
    
        # APE
        replace HIPAlignmentAlgorithm.apeParam = "linear" 
        replace HIPAlignmentAlgorithm.apeSPar = { 0.2, 0.0, 50. }
        replace HIPAlignmentAlgorithm.apeRPar = { 0.05, 0.0, 50. }

        # Track refitter (adapted to alignment needs)
        # include "RecoTracker/TransientTrackingRecHit/data/TransientTrackingRecHitBuilderWithoutRefit.cfi"
        include "RecoTracker/TransientTrackingRecHit/data/TransientTrackingRecHitBuilder.cfi" 
        include "RecoTracker/TrackProducer/data/RefitterWithMaterial.cff"
        replace TrackRefitter.src = "cosmictrackfinderRED"
        replace TrackRefitter.TTRHBuilder = "WithTrackAngle"
        replace TrackRefitter.TrajectoryInEvent = true

      	########################### input files       
        # include "Alignment/CommonAlignmentProducer/data/data-FNAL.cfi"
        source = PoolSource { 
		
		untracked vstring fileNames = { 
                   "rfio:/castor/cern.ch/user/c/covarell/reducedRootfiles/dataRED-6217.root"
                }
             	untracked int32 maxEvents   = 100
		untracked uint32 skipEvents = 0
	} 

        path p = { TrackRefitter }
    
        # REPLACEME (needed for inserting replace statements by perl script!)

}

